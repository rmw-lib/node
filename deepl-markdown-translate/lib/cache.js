// Generated by CoffeeScript 2.6.1
//!/usr/bin/env coffee
var Cache, RmwUtf8Db, split_p;

import {
  join
} from 'path';

import {
  homedir
} from 'os';

import {
  open
} from 'lmdb';

import blake3 from 'blake3';

import {
  encode,
  decode
} from '@rmw/utf8';

split_p = (xml) => {
  var li, np, p;
  p = 0;
  li = [];
  while (true) {
    np = xml.indexOf('</p>', p);
    if (np < 0) {
      if (p < xml.length) {
        li.push(xml.slice(p));
      }
      break;
    }
    np += 4;
    li.push(xml.slice(p, np));
    p = np;
  }
  return li;
};

RmwUtf8Db = class RmwUtf8Db {
  constructor(db1) {
    this.db = db1;
  }

  get(key) {
    var r;
    r = this.db.get(key);
    if (r) {
      return decode(r);
    }
  }

  set(key, val) {
    var e;
    e = encode(val);
    //console.log "compress ratio", (100*e.length/Buffer.from(val,'utf8').length) + "%"
    return this.db.put(key, e);
  }

};

export default Cache = class Cache {
  constructor(translate, db = join(homedir(), ".cache/markdown-translate/deepl")) {
    this._db = this._db.bind(this);
    this.translate = translate;
    this.db = open({
      path: db,
      maxDbs: 256
    });
    this.source_lang = this.translate.option.source_lang;
    this.lang_db = new Map();
  }

  _db(lang) {
    var db;
    db = this.lang_db.get(lang);
    if (!db) {
      db = new RmwUtf8Db(this.db.openDB(lang, {
        keyEncoding: 'binary',
        encoding: 'binary'
      }));
      this.lang_db.set(lang, db);
    }
    return db;
  }

  async xml(text, target_lang = "EN-US") {
    var cache, db, hash, i, j, len, li, not_exist, pos, r, ref, t, xml;
    db = this._db(target_lang);
    cache = new Map();
    not_exist = [];
    li = split_p(text);
    for (i of li) {
      hash = blake3.hash(i);
      r = db.get(hash);
      if (r) {
        cache.set(i, r);
      } else {
        not_exist.push(i);
      }
    }
    if (not_exist.length) {
      ref = split_p((await this.translate.xml(not_exist.join(''), target_lang)));
      for (pos = j = 0, len = ref.length; j < len; pos = ++j) {
        i = ref[pos];
        t = not_exist[pos];
        cache.set(t, i);
        hash = blake3.hash(t);
        await db.set(hash, i);
      }
    }
    xml = [];
    for (i of li) {
      xml.push(cache.get(i));
    }
    return xml.join('');
  }

  async txt(text, target_lang = "EN-US") {
    var db, hash, r;
    db = this._db(target_lang);
    hash = blake3.hash(text);
    r = db.get(hash);
    if (!r) {
      r = (await this.translate.txt(text, target_lang));
      await db.set(hash, r);
    }
    return r;
  }

};
